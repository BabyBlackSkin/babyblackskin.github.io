import{_ as a,a as e,b as t}from"./chunks/img_4.aSiRvzak.js";import{_ as l,c as o,o as d,a2 as i}from"./chunks/framework.DniMO-iw.js";const r="/assets/img_1.DNrnmgHc.png",S=JSON.parse('{"title":"锁","description":"","frontmatter":{},"headers":[],"relativePath":"article/database/mysql/lock.md","filePath":"article/database/mysql/lock.md"}'),c={name:"article/database/mysql/lock.md"},h=i('<h1 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to &quot;锁&quot;">​</a></h1><h2 id="锁的分类" tabindex="-1">锁的分类 <a class="header-anchor" href="#锁的分类" aria-label="Permalink to &quot;锁的分类&quot;">​</a></h2><ul><li>乐观锁</li><li>悲观锁： <ul><li>全局锁</li><li>表级锁 <ul><li>表锁 <ul><li>表共享读锁 Read Lock</li><li>表独占写锁 Write Lock</li></ul></li><li>元数据锁MDL</li><li>意向锁 <ul><li>IS锁，意向共享锁</li><li>IX锁，意向排他锁</li></ul></li></ul></li><li>行级锁 <ul><li>行锁 <ul><li>S锁，共享锁</li><li>X锁，排他锁</li></ul></li><li>间隙锁 Gap Lock</li><li>临键锁 Next-Key Lock</li></ul></li></ul></li></ul><h3 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h3><p>加锁命令：<code>Flush tables with read lock</code> 。对整个数据实例加锁。典型使用场景：全库逻辑备份</p><h3 id="表级索" tabindex="-1">表级索 <a class="header-anchor" href="#表级索" aria-label="Permalink to &quot;表级索&quot;">​</a></h3><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</p><h4 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to &quot;表锁&quot;">​</a></h4><p>命令：<code>lock tables ...read/write</code>。表锁可以分为读锁与写锁。可以用unlock tables主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。 表共享读锁：一旦某个客户端给表添加了共享读锁，那么它只能读不能写，且不会阻塞其他客户端的读操作而会阻塞其他客户端的写操作 表独占写锁：一旦某个客户端给表加了表锁，那么仅自己能够对表进行读写，阻塞其他客户端的读写操作</p><h3 id="元数据锁" tabindex="-1">元数据锁 <a class="header-anchor" href="#元数据锁" aria-label="Permalink to &quot;元数据锁&quot;">​</a></h3><p>MDL（metadata lock)元数据锁，所谓元数据就是描述数据的数据，这里可以理解为表的结构。它不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。如果一个查询正在遍历一个 表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 因此，在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁（共享锁）；当要对表做结构变更操作的时候，加MDL写锁（排他锁）。读锁之间是兼容的，写锁和读锁之间是互斥的。如下图所示，只有要改变表结构时才会加上写锁（EXCLUSIVE）。</p><p><img src="'+r+'" alt="image.png"></p><h3 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to &quot;意向锁&quot;">​</a></h3><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁。意向锁是一种表锁，锁定的粒度是整张表，分为意向共享锁(IS)和意向排他锁(IX)两类。当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁，这个标识就是意向锁。主要目的是为了提高加表锁的效率。</p><h4 id="意向共享锁-is" tabindex="-1">意向共享锁（IS） <a class="header-anchor" href="#意向共享锁-is" aria-label="Permalink to &quot;意向共享锁（IS）&quot;">​</a></h4><p>对整个表加共享锁之前，需要先获取到意向共享锁。由语句select...lock in share mode添加。</p><h4 id="意向排他锁-ix" tabindex="-1">意向排他锁（IX） <a class="header-anchor" href="#意向排他锁-ix" aria-label="Permalink to &quot;意向排他锁（IX）&quot;">​</a></h4><p>对整个表加排他锁之前，需要先获取到意向排他锁。由insert,update,delete,select...for update添加。</p><p>意向锁与其他锁的兼容互斥情况如下图所示，简单来说就是，<strong>意向锁之间是兼容的，意向排他锁和除了意向锁之外的锁都是互斥的，排他锁（X）与任何锁都是互斥的。</strong></p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>冲突</td><td>冲突</td><td>冲突</td><td>冲突</td></tr><tr><td>IX</td><td>冲突</td><td>兼容</td><td>冲突</td><td>兼容</td></tr><tr><td>S</td><td>冲突</td><td>冲突</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>冲突</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h3 id="行级锁" tabindex="-1">行级锁 <a class="header-anchor" href="#行级锁" aria-label="Permalink to &quot;行级锁&quot;">​</a></h3><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 行级锁是通过对索引上的索引项加锁来实现的。</p><h4 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to &quot;行锁&quot;">​</a></h4><p>行锁分为共享锁（S）和排他锁（X）。行锁是锁住单个记录的锁，防止其他事务对其update，delete的操作，在RR和RC隔离级别中都支持。 <img src="'+a+'" alt="image.png"> 当<code>WHERE</code>条件为非主键索引，执行<code>UPDATE</code>时，会经过一下步骤：</p><ol><li>先获取非主键索引的行级锁；</li><li>由数据库基本原理可知，<code>WHERE</code>条件为非主键索引时，会发生回表查询，进而再获得主键索引的行级锁；</li><li>更新完毕，进行事务提交。</li></ol><p>根据上述步骤可知，对于非主键索引的<code>UPDATE</code>操作，其加锁过程并非原子操作，而且是分别需要获取不同索引的行级锁，可能会产生死锁： 假如，一条<code>UPDATE</code>语句用到主键索引和非主键索引，则获取锁的顺序是先获取主键索引，再获取非主键索引；而同时，另一条<code>UPDATE</code>语句只用到非主键索引，则获取锁的顺序是先获取非主键索引，再获取主键索引，二者正好发生在步骤 1）和 2）中间，则会造成锁。</p><blockquote><p>当 update table set column where primary时，仅会给这一样数据加锁 当 update table set column where column时 ，会锁全表。存储引擎没办法知道哪些数据是符合条件的。如果一个条件无法通过索引快速过滤，那么存储引擎就会将所有记录加锁返回，在由 MySQL Server层进行过滤。但在实际使用过程中，MySQL做了一些改进，在MySQL Server过滤后，会将不满足条件的记录解锁（违背了二段锁协议的约束）。这样做保证了 最后只有满足条件的记录上锁。但每条记录的加锁还是不能省略。（参考《高性能MySQL》P181）</p></blockquote><h4 id="共享锁-读锁" tabindex="-1">共享锁（读锁） <a class="header-anchor" href="#共享锁-读锁" aria-label="Permalink to &quot;共享锁（读锁）&quot;">​</a></h4><p>当一个线程获取读锁后，会阻塞其他用户对该行数据的写操作（即阻止其他事务的排他锁），但不会阻止其他用户对该行数据的读操作（共享锁）</p><h4 id="排他锁-写锁" tabindex="-1">排他锁（写锁） <a class="header-anchor" href="#排他锁-写锁" aria-label="Permalink to &quot;排他锁（写锁）&quot;">​</a></h4><p>当一个线程获取写锁之后，会阻塞其他用户对该行数据的读写(<code>UPDATE、DELETE</code>操作,即其他事务不能够获得该行数据的共享锁与排他锁（获得锁才能对数据进行操作） MySQL InnoDB引擎默认的修改数据语句：<code>UPDATE、DELETE、INSERT</code>都会自动给涉及到的数据加上排他锁，<code>SELECT</code>语句默认不会加任何锁类型，如果加排他锁可以使用<code>SELECT … FOR UPDATE</code>语句，加共享锁可以使用<code>SELECT … LOCK IN SHARE MODE</code>语句</p><blockquote><p>InnoDB的行锁是通过对索引加的锁，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为<strong>表锁</strong>。</p></blockquote><h3 id="间隙锁-gap-lock" tabindex="-1">间隙锁（Gap lock） <a class="header-anchor" href="#间隙锁-gap-lock" aria-label="Permalink to &quot;间隙锁（Gap lock）&quot;">​</a></h3><p>间隙锁是锁住索引记录之间的间隙，防止其他事务在某个间隙进行insert的操作，产生幻读。在RR隔离级别中都支持。 <img src="'+e+'" alt="image.png"></p><h3 id="临键锁-next-key-lock" tabindex="-1">临键锁（Next-key lock） <a class="header-anchor" href="#临键锁-next-key-lock" aria-label="Permalink to &quot;临键锁（Next-key lock）&quot;">​</a></h3><p>临键锁是行锁和间隙锁的组合，同时锁住数据和数据之间的间隙，在RR的隔离级别中支持。 <img src="'+t+'" alt="image.png"> 默认情况下，InnoDB在RR的事务隔离级别运行，InnoDB会使用<code>Next-key lock</code>锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时,优化为间隙锁。</li><li>索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，<code>Next-Key Lock</code>退化为间隙锁。普通索引是非唯一的，所以有可能插入索引值一样的记录。如下图所示，如果再插入一条索引为18的数据，那么此时会对18-29这段间隙和16-18这段间隙进行加锁（<code>GAP LOCK</code>）。</li><li>索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。</li></ul>',37),n=[h];function s(p,u,k,m,b,q){return d(),o("div",null,n)}const P=l(c,[["render",s]]);export{S as __pageData,P as default};
