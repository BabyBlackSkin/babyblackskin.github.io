import{_ as a,a as e,b as t}from"./chunks/img_4.aSiRvzak.js";import{_ as o,c as r,o as n,a2 as i}from"./chunks/framework.DniMO-iw.js";const l="/assets/img_1.BRQ1S24h.png",x=JSON.parse('{"title":"索引","description":"","frontmatter":{},"headers":[],"relativePath":"article/database/mysql/index.md","filePath":"article/database/mysql/index.md"}'),h={name:"article/database/mysql/index.md"},s=i('<h1 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to &quot;索引&quot;">​</a></h1><p>索引（Index）是帮助MySQL高效获取数据的数据结构，简单来说，<strong>索引是一种数据结构。以协助快速查询、 更新数据库表中数据。</strong> MySQL数据库中innodb存储引擎，B+树索引可以分为聚簇索引（也称聚集索引，clustered index）和辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。</p><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><h3 id="聚簇索引和非聚簇索引" tabindex="-1"><strong>聚簇索引和非聚簇索引</strong> <a class="header-anchor" href="#聚簇索引和非聚簇索引" aria-label="Permalink to &quot;**聚簇索引和非聚簇索引**&quot;">​</a></h3><p>并不是一种单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式。</p><h4 id="聚簇索引" tabindex="-1">聚簇索引 <a class="header-anchor" href="#聚簇索引" aria-label="Permalink to &quot;聚簇索引&quot;">​</a></h4><p>按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引。如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p><h5 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h5><ol><li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li><li>聚簇索引对于主键的排序查找和范围查找速度非常快</li><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以 节省了大量的io操作 。</li></ol><h5 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h5><ol><li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键</li><li>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li><li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据</li></ol><h5 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h5><ol><li>对于mysql数据库中只有InnoDB支持聚簇索引，而MyISAM不支持聚簇索引。</li><li>由于数据物理存储方式只能有一种，而每个mysql的表只能有一个饿聚簇索引，一般情况下就是该表的主键。</li><li>如果没有定义主键，InnoDB会选择非空的唯一索引代替，如果没有这样的索引，InnoDB会隐式的定义一个主键来作为聚簇索引。</li><li>为了充分利用聚簇索引的聚簇的特性，索引InnoDB表的主键列尽量选用有序的id，而不建议使用无需的id，比如uuid，md5，hash，字符串作为主键将无法保证数据的顺序增常。</li></ol><h4 id="非聚簇索引" tabindex="-1"><strong>非聚簇索引</strong> <a class="header-anchor" href="#非聚簇索引" aria-label="Permalink to &quot;**非聚簇索引**&quot;">​</a></h4><p>也称辅助索引在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。Innodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。</p><h3 id="主键索引" tabindex="-1">主键索引： <a class="header-anchor" href="#主键索引" aria-label="Permalink to &quot;主键索引：&quot;">​</a></h3><p>用于唯一标识每一行数据的索引，每个表只能有一个主键索引，<strong>索引列中的值必须是唯一的，不允许有空值。</strong></p><h3 id="复合索引" tabindex="-1">复合索引 <a class="header-anchor" href="#复合索引" aria-label="Permalink to &quot;复合索引&quot;">​</a></h3><p>复合索引也叫多列索引或联合索引，它是包含多个列的索引类型，能够加速多列查询和排序操作。需要遵循<strong>最左前缀匹配原则（最左匹配原则）</strong></p><h3 id="普通索引" tabindex="-1">普通索引 <a class="header-anchor" href="#普通索引" aria-label="Permalink to &quot;普通索引&quot;">​</a></h3><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p><h3 id="唯一索引" tabindex="-1">唯一索引 <a class="header-anchor" href="#唯一索引" aria-label="Permalink to &quot;唯一索引&quot;">​</a></h3><p>唯一索引是用来保证列的唯一性的索引，一个表可以有多个唯一索引。<strong>索引列中的值必须是唯一的，但是允许为空值。</strong></p><h3 id="全文索引" tabindex="-1">全文索引 <a class="header-anchor" href="#全文索引" aria-label="Permalink to &quot;全文索引&quot;">​</a></h3><p>全文索引是一种用于全文搜索的索引类型，能够对文本数据进行快速的模糊搜索和关键字搜索。<strong>只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。</strong></p><h3 id="哈希索引" tabindex="-1">哈希索引 <a class="header-anchor" href="#哈希索引" aria-label="Permalink to &quot;哈希索引&quot;">​</a></h3><p>哈希索引是基于哈希表实现的索引类型，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引</p><h2 id="innodb引擎下的索引" tabindex="-1">Innodb引擎下的索引 <a class="header-anchor" href="#innodb引擎下的索引" aria-label="Permalink to &quot;Innodb引擎下的索引&quot;">​</a></h2><p>使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同.</p><h3 id="主键索引-1" tabindex="-1">主键索引： <a class="header-anchor" href="#主键索引-1" aria-label="Permalink to &quot;主键索引：&quot;">​</a></h3><p>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 <img src="'+l+'" alt="image.png"> 可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><h3 id="其他索引-非主键索引" tabindex="-1">其他索引（非主键索引） <a class="header-anchor" href="#其他索引-非主键索引" aria-label="Permalink to &quot;其他索引（非主键索引）&quot;">​</a></h3><p>InnoDB的所有辅助索引都引用主键作为data域。例如，下图为定义在Col3上的一个辅助索引，辅助索引的叶子节点包含了主键索引。所以使用辅助索引检索的时候需要检索两边，首先检索辅助索引获取主键，然后用主键索引检索获取记录 <img src="'+a+'" alt="image.png"></p><h3 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h3><p>在 MySQL 中，主要有四种类型的索引，分别为： B-Tree 索引， Hash 索引， Fulltext 索引和 R-Tree 索引。主要分析B-Tree 索引。</p><h4 id="hash表" tabindex="-1">Hash表 <a class="header-anchor" href="#hash表" aria-label="Permalink to &quot;Hash表&quot;">​</a></h4><p>使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p><h4 id="b树" tabindex="-1">B树 <a class="header-anchor" href="#b树" aria-label="Permalink to &quot;B树&quot;">​</a></h4><p>MySQL的数据是存储在磁盘文件中的，查询处理数据时，需要先把磁盘中的数据加载到内存中，磁盘IO操作非常耗时，所以我们优化的重点就是尽量减少磁盘IO操作。访问二叉树的每个结点就会发生一次IO，如果想要减少IO操作，就需要降低树的高度。</p><p>假如key为bigint，8字节，每个节点有两个指针，每个指针为4个字节，一个节点占用的空间16个字节（8+4*2=16）。</p><p>因为在MySQL的InnoDB存储引擎一次IO会读取的一页（默认一页16K）的数据量，而二叉树一次IO有效数据量只有16字节，空间利用率极低。为了最大化利用一次IO空间，一个简单的想法是在每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖。构建1百万条数据，树的高度只需要2层就可以（1000*1000=1百万），也就是说只需要2次磁盘IO就可以查询到数据。磁盘IO次数变少了，查询数据的效率也就提高了。</p><p>B树的节点中存储着多个元素，每个内节点有多个分叉。 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。 父节点当中的元素不会出现在子节点中。 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。 <img src="'+e+'" alt="image.png"> 例子： 假如我们查询值等于10的数据。查询路径磁盘块1-&gt;磁盘块2-&gt;磁盘块5。 第一次磁盘IO：将磁盘块1加载到内存中，在内存中从头遍历比较，10&lt;15，走左路，到磁盘寻址磁盘块2。 第二次磁盘IO：将磁盘块2加载到内存中，在内存中从头遍历比较，7&lt;10，到磁盘中寻址定位到磁盘块5。 第三次磁盘IO：将磁盘块5加载到内存中，在内存中从头遍历比较，10=10，找到10，取出data，如果data存储的行记录，取出data，查询结束。如果存储的是磁盘地址，还需要根据磁盘地址到磁盘中取出数据，查询终止。 相比二叉平衡查找树，在整个查找过程中，虽然数据的比较次数并没有明显减少，但是磁盘IO次数会大大减少。同时，由于我们的比较是在内存中进行的，比较的耗时可以忽略不计。B树的高度一般2至3层就能满足大部分的应用场景，所以使用B树构建索引可以很好的提升查询的效率。 <img src="'+t+'" alt="image.png"></p>',42),d=[s];function c(p,b,m,u,q,I){return n(),r("div",null,d)}const f=o(h,[["render",c]]);export{x as __pageData,f as default};
