import{_ as a,c as e,o as s,a2 as o}from"./chunks/framework.DniMO-iw.js";const l="/assets/img.j9ZQ0IN3.png",C=JSON.parse('{"title":"ClassLoader","description":"","frontmatter":{},"headers":[],"relativePath":"article/java/jvm/ClassLoader.md","filePath":"article/java/jvm/ClassLoader.md"}'),r={name:"article/java/jvm/ClassLoader.md"},t=o('<h1 id="classloader" tabindex="-1">ClassLoader <a class="header-anchor" href="#classloader" aria-label="Permalink to &quot;ClassLoader&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>ClassLoader（类加载器），是Java虚拟机中的一部分；所有的Class都是由ClassLoader加载的。主要负责 将class文件（字节码）加载到内存中，并生成一个Class对象。并交由JVM进行连接、初始化操作等。</p><p>ClassLoader在整个装载阶段，只负责类的加载，而不涉及类的连接、初始化等。</p><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><p>主要分为两大类：启动类加载器（Bootstrap ClassLoader）和应用类加载器（Application ClassLoader） 类加载子系统负责从文件系统或者网络中加载class文件。classLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。</p><p><img src="'+l+'" alt="img.png"></p><h3 id="bootstrap-classloader" tabindex="-1">Bootstrap ClassLoader <a class="header-anchor" href="#bootstrap-classloader" aria-label="Permalink to &quot;Bootstrap ClassLoader&quot;">​</a></h3><ul><li>启动类加载器有C语言编写，嵌套在JVM内核中，是所有类加载器的父类</li><li>用于加载Java核心类库。如：<code>Java</code>、<code>Javax</code>、<code>$JAVA_HOME\\jre\\lib\\rt.jar</code>、<code>$JAVA_HOME\\jre\\lib\\resources.jar</code>、<code>$JAVA_HOME\\jre\\lib\\charsets.jar</code>、<code>$JAVA_HOME\\jre\\classes</code>等目录中的一些<code>jar</code>包</li><li>无法通过<code>Java</code>代码访问。但可以通过<code>-Xbootclasspath</code>参数来指定启动类加载器加载的类路径。</li></ul><h3 id="extension-classloader" tabindex="-1">Extension ClassLoader <a class="header-anchor" href="#extension-classloader" aria-label="Permalink to &quot;Extension ClassLoader&quot;">​</a></h3><ul><li>由<code>sun.misc.Launcher$ExtClassLoader</code>实现</li><li>扩展类加载器，是启动类加载器的子类，用于加载<code>$JAVA_HOME\\jre\\lib\\ext</code>目录</li></ul><h3 id="application-classloader" tabindex="-1">Application ClassLoader <a class="header-anchor" href="#application-classloader" aria-label="Permalink to &quot;Application ClassLoader&quot;">​</a></h3><ul><li>由sun.misc.Launcher$AppClassLoader实现</li><li>负责加载环境变量中classpath或者java.class.path属性所指定的类路径。</li></ul><h3 id="user-classloader" tabindex="-1">User ClassLoader <a class="header-anchor" href="#user-classloader" aria-label="Permalink to &quot;User ClassLoader&quot;">​</a></h3><p>用户可以自定义的类加载器，实现类似插件的机制。Spring，Tomcat等框架都有着自己的类加载器。</p><h2 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h2>',16),c=[t];function d(i,n,h,p,u,_){return s(),e("div",null,c)}const L=a(r,[["render",d]]);export{C as __pageData,L as default};
