import{_ as a,c as e,o,a2 as t}from"./chunks/framework.DniMO-iw.js";const m=JSON.parse('{"title":"Jvm","description":"","frontmatter":{},"headers":[],"relativePath":"article/java/JVM.md","filePath":"article/java/JVM.md"}'),s={name:"article/java/JVM.md"},r=t('<h1 id="jvm" tabindex="-1">Jvm <a class="header-anchor" href="#jvm" aria-label="Permalink to &quot;Jvm&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>JVM 是 java虚拟机，是用来执行java字节码(二进制的形式)的虚拟计算机。主要分为五个模块</p><h2 id="类加载器" tabindex="-1">类加载器 <a class="header-anchor" href="#类加载器" aria-label="Permalink to &quot;类加载器&quot;">​</a></h2><p>类加载子系统负责从文件系统或者网络中加载class文件。classLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。 加载的类信息存放于一块称为方法区的内存空间。</p><p><strong><a href="./jvm/ClassLoader.html">ClassLoader</a></strong></p><ol><li><p>Bootstrap ClassLoader（引导类加载器）</p><p>最顶层的类加载器，由C++实现。 它负责加载JVM的基础类库，如rt.jar，位于<code>JRE/lib</code>目录下或者由<code>-Xbootclasspath</code>参数指定的路径。</p></li><li><p>Extension ClassLoader（扩展类加载器）</p><p>由sun.misc.Launcher$ExtClassLoader实现，是Java代码编写的。</p><p>它的父类加载器是Bootstrap ClassLoader。</p><p>负责加载<code>JRE/lib/ext</code>目录下的JAR文件或者由<code>-Djava.ext.dirs</code>系统属性指定的目录中的类库。</p></li><li><p>Application ClassLoader（应用程序类加载器）：</p><p>负责加载classpath中指定的jar包或者 -Djava.class.path所指定目录下的类和jar包。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</p></li></ol><p>这三层类加载器采用<strong>双亲委派机制</strong></p><p>当一个类加载器收到了类的加载请求。首先会交给父加载器去加载，依次向上传递。因为最终都会到Bootstrap ClassLoader加载。如果父类加载器无法加载，则子类尝试自己去加载</p><blockquote><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗地说：比较两个类是否”相等“，只有在这两个类是同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 这里所说的”相等“，包括代表类的Class对象的equals()方法、isAsignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字做对象所属关系判定等情况。</p></blockquote><p>好处：</p><ul><li>避免类的重复加载：在JVM中，每个类都由一个唯一的全限定名和一个对应的类加载器确定，类加载器根据全限定名和类路径来确定类的位置。因此一个JVM实例中，如果有两个类加载器分别加载了同一个类，JVM会认为这两个类是不同的，从而导致类型转换异常等问题。通过双亲委派机制，类加载器在加载类之前会先委托给自己的父类加载器去加载，从而保证一个类在JVM中只会有一份，并且由其父类加载器所加载</li><li>保护程序安全，防止核心API被随意篡改：Java核心类库（java.lang 包下的类）都是由启动类加载器加载的，其他的类都是由其他类加载器加载的。这样，我们可以保证Java核心类库的安全性，因为不同的应用程序无法改变这些类的实现。</li></ul><h2 id="运行时数据区" tabindex="-1">运行时数据区 <a class="header-anchor" href="#运行时数据区" aria-label="Permalink to &quot;运行时数据区&quot;">​</a></h2><h2 id="执行引擎" tabindex="-1">执行引擎 <a class="header-anchor" href="#执行引擎" aria-label="Permalink to &quot;执行引擎&quot;">​</a></h2><h2 id="本地库接口" tabindex="-1">本地库接口 <a class="header-anchor" href="#本地库接口" aria-label="Permalink to &quot;本地库接口&quot;">​</a></h2><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2>',16),l=[r];function i(c,n,d,p,h,u){return o(),e("div",null,l)}const J=a(s,[["render",i]]);export{m as __pageData,J as default};
