import{_ as e,c as a,o as n,a2 as s}from"./chunks/framework.DniMO-iw.js";const l="/assets/1.DrSpI40T.png",x=JSON.parse('{"title":"线程池","description":"","frontmatter":{},"headers":[],"relativePath":"article/java/threadPool/1_index.md","filePath":"article/java/threadPool/1_index.md"}'),o={name:"article/java/threadPool/1_index.md"},i=s(`<h1 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>线程池，就是一个用来管理线程的池子，为我们管理线程提供来帮助，避免频繁的创建和销毁线程造成资源的损耗。 当线程的任务执行完成后并不会立即的回收，只要在满足回收条件后，如果在未回收之前，线程池收到了新的任务，则会重复利用当前存活的线程，节省资源</p><h2 id="线程池的创建" tabindex="-1">线程池的创建 <a class="header-anchor" href="#线程池的创建" aria-label="Permalink to &quot;线程池的创建&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>public ThreadPoolExecutor(   int corePoolSize,</span></span>
<span class="line"><span>                              int maximumPoolSize,</span></span>
<span class="line"><span>                              long keepAliveTime,</span></span>
<span class="line"><span>                              TimeUnit unit,</span></span>
<span class="line"><span>                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span>
<span class="line"><span>                              ThreadFactory threadFactory,</span></span>
<span class="line"><span>                              RejectedExecutionHandler handler) {</span></span>
<span class="line"><span>                              </span></span>
<span class="line"><span>}</span></span></code></pre></div><p>核心参数：</p><p><strong>corePoolSize</strong>: 核心线程数。即线程池最小存活的线程数量。</p><ul><li>当调用execute()方法时， 如果线程池中的线程数量小于核心线程数，即时存在空闲的线程。也会创建新的线程来执行任务。</li></ul><p><strong>maximumPoolSize</strong>: 最大线程数。即线程池中最多可以创建的线程数</p><ul><li>当没有空闲的核心线程，blockQueue已满，且当前线程数 &lt; <code>maximumPoolSize</code>时，会创建新的线程来执行任务</li></ul><p><strong>keepAliveTime</strong>：非核心线程的存活时间</p><ul><li>当非核心线程处于空闲状态时，持续的时间达到了<code>keepAliveTime</code>，线程池会回收该线程。</li></ul><p><strong>unit</strong>：keepAliveTime的单位</p><p><strong>workQueue</strong>：任务队列，用来存放未执行的任务。</p><p><strong>threadFactory</strong>：线程工厂，用来创建线程。</p><p><strong>handler</strong>：拒绝策略，当任务执行队列已满，且线程池中的线程数达到最大值时，会执行拒绝策略。</p><h3 id="通过executor工厂类快速创建线程池" tabindex="-1">通过Executor工厂类快速创建线程池 <a class="header-anchor" href="#通过executor工厂类快速创建线程池" aria-label="Permalink to &quot;通过Executor工厂类快速创建线程池&quot;">​</a></h3><ul><li><p>Executors.newCachedThreadPool()<br> 创建一个线程池，线程数量没有上限，线程数量随任务数量变化。线程可用被重用，核心线程数0， 创建的都是非核心线程，且第一次使用时才创建，对于服务器压力较大</p></li><li><p>Executors.newFixedThreadPool();<br> 规定固定的线程池大小，当线程数达到指定数量时，拒绝创建</p></li><li><p>Executors.newSingleThreadExecutor()<br> 单线程的线程池</p></li></ul><h2 id="任务的执行" tabindex="-1">任务的执行 <a class="header-anchor" href="#任务的执行" aria-label="Permalink to &quot;任务的执行&quot;">​</a></h2><p><img src="`+l+'" alt="img.png"></p><h3 id="拒绝策略" tabindex="-1">拒绝策略 <a class="header-anchor" href="#拒绝策略" aria-label="Permalink to &quot;拒绝策略&quot;">​</a></h3><ul><li>AbortPolicy：默认策略，处理新任务时直接抛出<code>RejectedExecutionException</code>异常</li><li>CallerRunsPolicy：交给线程池调用所在的线程进行处理</li><li>DiscardPolicy：直接丢弃任务</li><li>DiscardOldestPolicy：丢弃队列中最旧的任务，然后尝试重新提交当前任务</li></ul>',22),t=[i];function r(p,c,d,u,h,m){return n(),a("div",null,t)}const g=e(o,[["render",r]]);export{x as __pageData,g as default};
