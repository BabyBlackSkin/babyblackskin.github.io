import{_ as e,c as a,o as r,a2 as t}from"./chunks/framework.DniMO-iw.js";const o="/assets/1.BQmuj-t4.png",c="/assets/2.D-RHCR59.png",i="/assets/3.D-qWn2sK.png",d="/assets/4.Dzpbq4pP.png",b=JSON.parse('{"title":"Docker","description":"","frontmatter":{},"headers":[],"relativePath":"article/devops/5_docker/Index.md","filePath":"article/devops/5_docker/Index.md"}'),n={name:"article/devops/5_docker/Index.md"},s=t('<h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to &quot;Docker&quot;">​</a></h1><h2 id="什么是docker" tabindex="-1">什么是Docker <a class="header-anchor" href="#什么是docker" aria-label="Permalink to &quot;什么是Docker&quot;">​</a></h2><p>Docker是一个操作系统层面的虚拟化技术，是一个开源的容器化平台，设计用于简化应用程序的创建、部署和运行过程。 它将应用及其所有依赖打包进一个轻量级、可移植的容器中， 这样应用程序就能在任何安装有 Docker 的环境中无缝运行，无需担心环境差异带来的问题。</p><h2 id="什么是虚拟化" tabindex="-1">什么是虚拟化 <a class="header-anchor" href="#什么是虚拟化" aria-label="Permalink to &quot;什么是虚拟化&quot;">​</a></h2><p>在计算机中，虚拟化（英语：Virtualization）是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来， 打破实体结构间的不可切割的障碍，使用户可以比原本的组态更好的方式来应用这些资源。这些资源的新虚拟部份是不受现有资源的架设方式，地域或物理组态所限制。 一般所指的虚拟化资源包括计算能力和资料存储。 在实际的生产环境中，虚拟化技术主要用来解决高性能的物理硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层物理硬件，从而最大化的利用物理硬件 对资源充分利用 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等</p><h2 id="docker的虚拟化" tabindex="-1">Docker的虚拟化 <a class="header-anchor" href="#docker的虚拟化" aria-label="Permalink to &quot;Docker的虚拟化&quot;">​</a></h2><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大地简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><p><strong>传统虚拟技术</strong></p><p><img src="'+o+'" alt="image.png"></p><p><strong>docker</strong></p><p><img src="'+c+'" alt="image.png"></p><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>磁盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>较弱</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table><h2 id="docker的核心概念" tabindex="-1">Docker的核心概念： <a class="header-anchor" href="#docker的核心概念" aria-label="Permalink to &quot;Docker的核心概念：&quot;">​</a></h2><h3 id="服务器与客户端" tabindex="-1">服务器与客户端： <a class="header-anchor" href="#服务器与客户端" aria-label="Permalink to &quot;服务器与客户端：&quot;">​</a></h3><p>Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。 Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接 到运行在另一台宿主机上的远程Docker守护进程。</p><p><img src="'+i+'" alt="image.png"></p><h3 id="容器-container" tabindex="-1">容器（Container）： <a class="header-anchor" href="#容器-container" aria-label="Permalink to &quot;容器（Container）：&quot;">​</a></h3><p>容器是 Docker 的基本部署单元。它是从镜像创建的运行实例，一个轻量级的、独立的运行时环境，包含应用程序及其相关依赖。 容器利用 Linux 内核的命名空间和控制组技术，实现了隔 离性和资源管理，使得应用程序在不同的容器中运行不会相互影响。</p><h3 id="镜像-image" tabindex="-1">镜像（Image）： <a class="header-anchor" href="#镜像-image" aria-label="Permalink to &quot;镜像（Image）：&quot;">​</a></h3><p>镜像是用于创建容器的模板，也是Docker生命周期中的“构建”部分。用户基于镜像来运行自己的容器。镜像是基于联合文件系统的一种层式结构， -由一系列指令一步一步构建出来。例如：它包含了一个完整的文件系统，其中包括应用程序运行所需的所有文件、依赖和配置信息。镜像是不可变的，通过 Docker 镜像可以创建 多个相同的容器实例。</p><h4 id="分层机制" tabindex="-1">分层机制 <a class="header-anchor" href="#分层机制" aria-label="Permalink to &quot;分层机制&quot;">​</a></h4><p>Docker 设计时 采用了Union FS 分层存储技术，即镜像由多个只读层组成，每个层都是一个只读的镜像文件系统，层之间通过只读的联合文件系统连接起来。 避免一个镜像包含完整的系统文件导致过大 <img src="'+d+'" alt="image.png"></p><h3 id="镜像仓库-image-registry" tabindex="-1">镜像仓库（Image Registry）： <a class="header-anchor" href="#镜像仓库-image-registry" aria-label="Permalink to &quot;镜像仓库（Image Registry）：&quot;">​</a></h3><p>镜像仓库是用于存储和分发 Docker 镜像的地方。最常用的公共镜像仓库是 Docker Hub，上面有大量的官方和社区共享的镜像。此外，还可以搭建私有的镜像仓库 ，用于存放自己的镜像。</p><h3 id="dockerfile" tabindex="-1">Dockerfile： <a class="header-anchor" href="#dockerfile" aria-label="Permalink to &quot;Dockerfile：&quot;">​</a></h3><p>Dockerfile 是一种文本文件，用于定义 Docker 镜像的构建过程。它包含了一系列的指令，用于指定基础镜像、安装软件、拷贝文件、配置环境等 。通过 Dockerfile，可以自动化地构建镜像，确保镜像的一致性和可重复性。</p>',26),l=[s];function h(k,p,m,_,D,g){return r(),a("div",null,l)}const f=e(n,[["render",h]]);export{b as __pageData,f as default};
