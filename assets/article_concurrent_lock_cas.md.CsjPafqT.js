import{_ as e,c as o,o as c,a2 as a}from"./chunks/framework.DniMO-iw.js";const t="/assets/1.D8R5XLat.png",s="/assets/2.DmI4wRfz.png",r="/assets/3.DU5_n8ix.png",d="/assets/4.CTJklit6.png",S=JSON.parse('{"title":"CAS锁","description":"","frontmatter":{},"headers":[],"relativePath":"article/concurrent/lock/cas.md","filePath":"article/concurrent/lock/cas.md"}'),n={name:"article/concurrent/lock/cas.md"},p=a('<h1 id="cas锁" tabindex="-1">CAS锁 <a class="header-anchor" href="#cas锁" aria-label="Permalink to &quot;CAS锁&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p><code>CAS（Compare And Swap）</code>, 即比较并交换，在<code>CAS</code>中适使用的三个基本操作数：内存地址（<code>i</code>）、旧值（<code>A</code>），新值（<code>B</code>）。</p><h2 id="机制" tabindex="-1">机制 <a class="header-anchor" href="#机制" aria-label="Permalink to &quot;机制&quot;">​</a></h2><p>当需要多一个变量进行修改时，会将内存地址（<code>i</code>）与旧值（<code>A</code>）比较，如果相等，则将新值（<code>B</code>）赋给旧值（<code>A</code>）， 否则将内存地址（<code>i</code>）作为旧值（<code>A</code>），再次比较，直到相等（自旋）</p><p><strong>成功的例子</strong></p><p>变量<code>i</code>的初始值为1</p><p>线程1：对它进行<code>+1</code>的操作</p><p><img src="'+t+'" alt="img.png"></p><p><strong>失败的例子</strong></p><p>变量<code>i</code>的初始值为1</p><p>线程1：对它进行<code>+1</code>的操作</p><p>线程2：对它进行<code>+3</code>的操作</p><p><img src="'+s+'" alt="img.png"><img src="'+r+'" alt="img.png"><img src="'+d+'" alt="img.png"></p><h2 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h2><p><strong>优点</strong></p><p>在并发量少或者对变量修改操作少的时候，效率会比传统的加锁高，因为不涉及用户态和内核态的切换。</p><p><strong>缺点</strong></p><p>自旋进行比较和替换，当并发量大的时候可能会因为变量一直更新而无法比较成功，而不断地进行自旋，导致CPU压力过大 CAS只能保证一个变量的原子性，并不能保证整个代码块的原子性，所以在处理多个变量的原子性更新的时候还是得加锁。</p>',19),i=[p];function l(_,m,h,g,u,A){return c(),o("div",null,i)}const C=e(n,[["render",l]]);export{S as __pageData,C as default};
